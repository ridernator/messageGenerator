// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___CONFIG_STRUCTURE_HXX
#define CXX___CONFIG_STRUCTURE_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4009911L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class SimpleType;
class ExtendedType;
class Type;
class Constant;
class Element;
class Constants;
class Elements;
class Structure;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#ifndef XSD_DONT_INCLUDE_INLINE
#define XSD_DONT_INCLUDE_INLINE

#undef XSD_DONT_INCLUDE_INLINE
#else

#endif // XSD_DONT_INCLUDE_INLINE

class SimpleType: public ::xml_schema::String
{
  public:
  enum Value
  {
    unsigned_int_8,
    unsigned_int_16,
    unsigned_int_32,
    unsigned_int_64,
    int_8,
    int_16,
    int_32,
    int_64,
    float_32,
    float_64,
    string
  };

  SimpleType (Value v);

  SimpleType (const char* v);

  SimpleType (const ::std::string& v);

  SimpleType (const ::xml_schema::String& v);

  SimpleType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  SimpleType (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  SimpleType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  SimpleType (const SimpleType& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

  virtual SimpleType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  SimpleType&
  operator= (Value v);

  virtual
  operator Value () const
  {
    return _xsd_SimpleType_convert ();
  }

  protected:
  Value
  _xsd_SimpleType_convert () const;

  public:
  static const char* const _xsd_SimpleType_literals_[11];
  static const Value _xsd_SimpleType_indexes_[11];
};

class ExtendedType: public ::xml_schema::String
{
  public:
  enum Value
  {
    complex_unsigned_int_8,
    complex_unsigned_int_16,
    complex_unsigned_int_32,
    complex_unsigned_int_64,
    complex_int_8,
    complex_int_16,
    complex_int_32,
    complex_int_64,
    complex_float_32,
    complex_float_64,
    array,
    sequence,
    map,
    structure
  };

  ExtendedType (Value v);

  ExtendedType (const char* v);

  ExtendedType (const ::std::string& v);

  ExtendedType (const ::xml_schema::String& v);

  ExtendedType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  ExtendedType (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  ExtendedType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  ExtendedType (const ExtendedType& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

  virtual ExtendedType*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  ExtendedType&
  operator= (Value v);

  virtual
  operator Value () const
  {
    return _xsd_ExtendedType_convert ();
  }

  protected:
  Value
  _xsd_ExtendedType_convert () const;

  public:
  static const char* const _xsd_ExtendedType_literals_[14];
  static const Value _xsd_ExtendedType_indexes_[14];
};

class Type: public ::xml_schema::String
{
  public:
  enum Value
  {
    unsigned_int_8,
    unsigned_int_16,
    unsigned_int_32,
    unsigned_int_64,
    int_8,
    int_16,
    int_32,
    int_64,
    float_32,
    float_64,
    string,
    complex_unsigned_int_8,
    complex_unsigned_int_16,
    complex_unsigned_int_32,
    complex_unsigned_int_64,
    complex_int_8,
    complex_int_16,
    complex_int_32,
    complex_int_64,
    complex_float_32,
    complex_float_64,
    array,
    sequence,
    map,
    structure
  };

  Type (Value v);

  Type (const char* v);

  Type (const ::std::string& v);

  Type (const ::xml_schema::String& v);

  Type (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

  Type (const ::xercesc::DOMAttr& a,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

  Type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

  Type (const Type& x,
        ::xml_schema::Flags f = 0,
        ::xml_schema::Container* c = 0);

  virtual Type*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  Type&
  operator= (Value v);

  virtual
  operator Value () const
  {
    return _xsd_Type_convert ();
  }

  protected:
  Value
  _xsd_Type_convert () const;

  public:
  static const char* const _xsd_Type_literals_[25];
  static const Value _xsd_Type_indexes_[25];
};

class Constant: public ::xml_schema::Type
{
  public:
  // documentation
  //
  typedef ::xml_schema::String DocumentationType;
  typedef ::xsd::cxx::tree::optional< DocumentationType > DocumentationOptional;
  typedef ::xsd::cxx::tree::traits< DocumentationType, char > DocumentationTraits;

  const DocumentationOptional&
  getDocumentation () const;

  DocumentationOptional&
  getDocumentation ();

  void
  setDocumentation (const DocumentationType& x);

  void
  setDocumentation (const DocumentationOptional& x);

  void
  setDocumentation (::std::unique_ptr< DocumentationType > p);

  // name
  //
  typedef ::xml_schema::String NameType;
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  const NameType&
  getName () const;

  NameType&
  getName ();

  void
  setName (const NameType& x);

  void
  setName (::std::unique_ptr< NameType > p);

  // type
  //
  typedef ::SimpleType TypeType;
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  const TypeType&
  getType () const;

  TypeType&
  getType ();

  void
  setType (const TypeType& x);

  void
  setType (::std::unique_ptr< TypeType > p);

  // value
  //
  typedef ::xml_schema::String ValueType;
  typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

  const ValueType&
  getValue () const;

  ValueType&
  getValue ();

  void
  setValue (const ValueType& x);

  void
  setValue (::std::unique_ptr< ValueType > p);

  // Constructors.
  //
  Constant (const NameType&,
            const TypeType&,
            const ValueType&);

  Constant (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

  Constant (const Constant& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

  virtual Constant*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  Constant&
  operator= (const Constant& x);

  virtual 
  ~Constant ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  DocumentationOptional documentation_;
  ::xsd::cxx::tree::one< NameType > name_;
  ::xsd::cxx::tree::one< TypeType > type_;
  ::xsd::cxx::tree::one< ValueType > value_;
};

class Element: public ::xml_schema::Type
{
  public:
  // documentation
  //
  typedef ::xml_schema::String DocumentationType;
  typedef ::xsd::cxx::tree::optional< DocumentationType > DocumentationOptional;
  typedef ::xsd::cxx::tree::traits< DocumentationType, char > DocumentationTraits;

  const DocumentationOptional&
  getDocumentation () const;

  DocumentationOptional&
  getDocumentation ();

  void
  setDocumentation (const DocumentationType& x);

  void
  setDocumentation (const DocumentationOptional& x);

  void
  setDocumentation (::std::unique_ptr< DocumentationType > p);

  // subElement
  //
  typedef ::Element SubElementType;
  typedef ::xsd::cxx::tree::optional< SubElementType > SubElementOptional;
  typedef ::xsd::cxx::tree::traits< SubElementType, char > SubElementTraits;

  const SubElementOptional&
  getSubElement () const;

  SubElementOptional&
  getSubElement ();

  void
  setSubElement (const SubElementType& x);

  void
  setSubElement (const SubElementOptional& x);

  void
  setSubElement (::std::unique_ptr< SubElementType > p);

  // subElement2
  //
  typedef ::Element SubElement2Type;
  typedef ::xsd::cxx::tree::optional< SubElement2Type > SubElement2Optional;
  typedef ::xsd::cxx::tree::traits< SubElement2Type, char > SubElement2Traits;

  const SubElement2Optional&
  getSubElement2 () const;

  SubElement2Optional&
  getSubElement2 ();

  void
  setSubElement2 (const SubElement2Type& x);

  void
  setSubElement2 (const SubElement2Optional& x);

  void
  setSubElement2 (::std::unique_ptr< SubElement2Type > p);

  // name
  //
  typedef ::xml_schema::String NameType;
  typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  const NameOptional&
  getName () const;

  NameOptional&
  getName ();

  void
  setName (const NameType& x);

  void
  setName (const NameOptional& x);

  void
  setName (::std::unique_ptr< NameType > p);

  // arraySize
  //
  typedef ::xml_schema::String ArraySizeType;
  typedef ::xsd::cxx::tree::optional< ArraySizeType > ArraySizeOptional;
  typedef ::xsd::cxx::tree::traits< ArraySizeType, char > ArraySizeTraits;

  const ArraySizeOptional&
  getArraySize () const;

  ArraySizeOptional&
  getArraySize ();

  void
  setArraySize (const ArraySizeType& x);

  void
  setArraySize (const ArraySizeOptional& x);

  void
  setArraySize (::std::unique_ptr< ArraySizeType > p);

  // type
  //
  typedef ::Type TypeType;
  typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

  const TypeType&
  getType () const;

  TypeType&
  getType ();

  void
  setType (const TypeType& x);

  void
  setType (::std::unique_ptr< TypeType > p);

  // structureName
  //
  typedef ::xml_schema::String StructureNameType;
  typedef ::xsd::cxx::tree::optional< StructureNameType > StructureNameOptional;
  typedef ::xsd::cxx::tree::traits< StructureNameType, char > StructureNameTraits;

  const StructureNameOptional&
  getStructureName () const;

  StructureNameOptional&
  getStructureName ();

  void
  setStructureName (const StructureNameType& x);

  void
  setStructureName (const StructureNameOptional& x);

  void
  setStructureName (::std::unique_ptr< StructureNameType > p);

  // Constructors.
  //
  Element (const TypeType&);

  Element (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

  Element (const Element& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

  virtual Element*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  Element&
  operator= (const Element& x);

  virtual 
  ~Element ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  DocumentationOptional documentation_;
  SubElementOptional subElement_;
  SubElement2Optional subElement2_;
  NameOptional name_;
  ArraySizeOptional arraySize_;
  ::xsd::cxx::tree::one< TypeType > type_;
  StructureNameOptional structureName_;
};

class Constants: public ::xml_schema::Type
{
  public:
  // constant
  //
  typedef ::Constant ConstantType;
  typedef ::xsd::cxx::tree::sequence< ConstantType > ConstantSequence;
  typedef ConstantSequence::iterator ConstantIterator;
  typedef ConstantSequence::const_iterator ConstantConstIterator;
  typedef ::xsd::cxx::tree::traits< ConstantType, char > ConstantTraits;

  const ConstantSequence&
  getConstant () const;

  ConstantSequence&
  getConstant ();

  void
  setConstant (const ConstantSequence& s);

  // Constructors.
  //
  Constants ();

  Constants (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  Constants (const Constants& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  virtual Constants*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  Constants&
  operator= (const Constants& x);

  virtual 
  ~Constants ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ConstantSequence constant_;
};

class Elements: public ::xml_schema::Type
{
  public:
  // element
  //
  typedef ::Element ElementType;
  typedef ::xsd::cxx::tree::sequence< ElementType > ElementSequence;
  typedef ElementSequence::iterator ElementIterator;
  typedef ElementSequence::const_iterator ElementConstIterator;
  typedef ::xsd::cxx::tree::traits< ElementType, char > ElementTraits;

  const ElementSequence&
  getElement () const;

  ElementSequence&
  getElement ();

  void
  setElement (const ElementSequence& s);

  // Constructors.
  //
  Elements ();

  Elements (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

  Elements (const Elements& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

  virtual Elements*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  Elements&
  operator= (const Elements& x);

  virtual 
  ~Elements ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  ElementSequence element_;
};

class Structure: public ::xml_schema::Type
{
  public:
  // documentation
  //
  typedef ::xml_schema::String DocumentationType;
  typedef ::xsd::cxx::tree::optional< DocumentationType > DocumentationOptional;
  typedef ::xsd::cxx::tree::traits< DocumentationType, char > DocumentationTraits;

  const DocumentationOptional&
  getDocumentation () const;

  DocumentationOptional&
  getDocumentation ();

  void
  setDocumentation (const DocumentationType& x);

  void
  setDocumentation (const DocumentationOptional& x);

  void
  setDocumentation (::std::unique_ptr< DocumentationType > p);

  // constants
  //
  typedef ::Constants ConstantsType;
  typedef ::xsd::cxx::tree::optional< ConstantsType > ConstantsOptional;
  typedef ::xsd::cxx::tree::traits< ConstantsType, char > ConstantsTraits;

  const ConstantsOptional&
  getConstants () const;

  ConstantsOptional&
  getConstants ();

  void
  setConstants (const ConstantsType& x);

  void
  setConstants (const ConstantsOptional& x);

  void
  setConstants (::std::unique_ptr< ConstantsType > p);

  // elements
  //
  typedef ::Elements ElementsType;
  typedef ::xsd::cxx::tree::optional< ElementsType > ElementsOptional;
  typedef ::xsd::cxx::tree::traits< ElementsType, char > ElementsTraits;

  const ElementsOptional&
  getElements () const;

  ElementsOptional&
  getElements ();

  void
  setElements (const ElementsType& x);

  void
  setElements (const ElementsOptional& x);

  void
  setElements (::std::unique_ptr< ElementsType > p);

  // name
  //
  typedef ::xml_schema::String NameType;
  typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

  const NameType&
  getName () const;

  NameType&
  getName ();

  void
  setName (const NameType& x);

  void
  setName (::std::unique_ptr< NameType > p);

  // Constructors.
  //
  Structure (const NameType&);

  Structure (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  Structure (const Structure& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

  virtual Structure*
  _clone (::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0) const;

  Structure&
  operator= (const Structure& x);

  virtual 
  ~Structure ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::Flags);

  protected:
  DocumentationOptional documentation_;
  ConstantsOptional constants_;
  ElementsOptional elements_;
  ::xsd::cxx::tree::one< NameType > name_;
};

#ifndef XSD_DONT_INCLUDE_INLINE

#endif // XSD_DONT_INCLUDE_INLINE

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, SimpleType::Value);

::std::ostream&
operator<< (::std::ostream&, const SimpleType&);

::std::ostream&
operator<< (::std::ostream&, ExtendedType::Value);

::std::ostream&
operator<< (::std::ostream&, const ExtendedType&);

::std::ostream&
operator<< (::std::ostream&, Type::Value);

::std::ostream&
operator<< (::std::ostream&, const Type&);

::std::ostream&
operator<< (::std::ostream&, const Constant&);

::std::ostream&
operator<< (::std::ostream&, const Element&);

::std::ostream&
operator<< (::std::ostream&, const Constants&);

::std::ostream&
operator<< (::std::ostream&, const Elements&);

::std::ostream&
operator<< (::std::ostream&, const Structure&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::Structure >
parseStructure (const ::std::string& uri,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (const ::std::string& uri,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (const ::std::string& uri,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

// Parse std::istream.
//

::std::unique_ptr< ::Structure >
parseStructure (::std::istream& is,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::std::istream& is,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::std::istream& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::std::istream& is,
                const ::std::string& id,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::Structure >
parseStructure (::xercesc::InputSource& is,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::xercesc::InputSource& is,
                ::xml_schema::ErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::xercesc::InputSource& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::Structure >
parseStructure (const ::xercesc::DOMDocument& d,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

::std::unique_ptr< ::Structure >
parseStructure (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::Flags f = 0,
                const ::xml_schema::Properties& p = ::xml_schema::Properties ());

#ifndef XSD_DONT_INCLUDE_INLINE
#include "Structure.ixx"
#endif // XSD_DONT_INCLUDE_INLINE

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___CONFIG_STRUCTURE_HXX
